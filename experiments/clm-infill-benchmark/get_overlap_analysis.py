# Copyright (c) 2024 Oebele Lijzenga
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Returns a list of infills only correctly generated by a single PLM, and returns a matrix of
overlap of bug fixes between all PLMs.
"""

import fire
import json
import os

from print_results import find_result_jsons
from get_infill_uniqueness import get_best_results_for_models, perfect

PLMS_ORDER = [
    'unixcoder_base', 
    'refact_1_6B-fim', 
    'santacoder_', 
    'codeshell_7B', 
    'starcoder_', 
    'plbart_base', 
    'plbart_large', 
    'codet5_small', 
    'codet5_base', 
    'codet5_large', 
    'codellama_7B', 
    'codellama_13B', 
    'codellama_7B-instruct', 
    'codellama_13B-instruct', 
    'codegen2_1B', 
    'codegen2_3_7B', 
    'codegen2_7B', 
    'codegen2_16B',
    'incoder_1B', 
    'incoder_6B'
]

PLMS_DISPLAY_NAME = {
    'unixcoder_base': 'UniXCoder', 
    'refact_1_6B-fim': 'Refact', 
    'santacoder_': 'SantaCoder', 
    'codeshell_7B': 'CodeShell', 
    'starcoder_': 'StarCoder', 
    'plbart_base': 'PLBART Base', 
    'plbart_large': 'PLBART Large', 
    'codet5_small': 'CodeT5 Small', 
    'codet5_base': 'CodeT5 Base', 
    'codet5_large': 'CodeT5 Large', 
    'codellama_7B': 'CodeLLaMA 7B', 
    'codellama_13B': 'CodeLLaMA 13B', 
    'codellama_7B-instruct': 'CodeLLaMA Instruct 7B', 
    'codellama_13B-instruct': 'CodeLLaMA Instruct 13B', 
    'codegen2_1B': 'CodeGen2 1B', 
    'codegen2_3_7B': 'CodeGen2 3.7B', 
    'codegen2_7B': 'CodeGen2 7B', 
    'codegen2_16B': 'CodeGen2 16B',
    'incoder_1B': 'InCoder 1B', 
    'incoder_6B': 'InCoder 6B'
}


def slug(data: dict) -> str:
    model_name = data['config']['model_name']
    model_variant = data['config']['model_variant']
    return f"{model_name}_{model_variant}"


def get_fixed_by(result_data: list[dict], n: int) -> dict[str, list[str]]:
    fixed_by = {task: [] for task in perfect}

    for data in result_data:
        for task, results in data['results'].items():
            if any(r == 'SUCCESS' for r in list(results)[:n]):
                fixed_by[task].append(slug(data))

    return fixed_by


def get_unique_fixes(result_data: list[dict], n: int) -> list[tuple[str, str]]:
    fixed_by = get_fixed_by(result_data, n)

    unique_fixes = []
    for task, fixers in fixed_by.items():
        if len(fixers) > 1:
            continue

        if len(fixers) == 0:
            unique_fixes.append((task, None))
        else:
            unique_fixes.append((task, fixers[0]))
    return unique_fixes


def get_venn_matrix(result_data: list[dict], n: int) -> dict[str, dict[str, int]]:
    fixed_by = get_fixed_by(result_data, n)
    plms = [slug(data) for data in result_data]

    matrix = {}
    for plm1 in plms:
        matrix[plm1] = {}
        for plm2 in plms:
            x = 0
            for _, fixers in fixed_by.items():
                if plm1 in fixers and plm2 in fixers:
                    x += 1
            matrix[plm1][plm2] = x
    return matrix


def render_table(data: list[tuple|list]) -> str:
    result = ""
    for row in data:
        result += ", ".join(str(elem) for elem in row) + "\n"
    return result


def main(dirname: str, n: int = 1):
    result_files_content = {}
    dirs = os.listdir(dirname)
    for dir_ in dirs:
        if not os.path.isdir(os.path.join(dirname, dir_)):
            continue

        result_files = find_result_jsons(os.path.join(dirname, dir_))
        for file_path in result_files:
            with open(file_path, 'r') as f:
                result_files_content[file_path] = json.loads(f.read())

    best_results = get_best_results_for_models(result_files_content, n)

    unique_fixes = get_unique_fixes(list(best_results.values()), n)
    print("Unique fixes:")
    print(render_table([("Task", "PLM")] + unique_fixes))
    print("")

    # Sort values results based on PLM order shown in the paper
    best_result_values = list(best_results.values())
    best_result_values.sort(key=lambda data: PLMS_ORDER.index(f"{data['config']['model_name']}_{data['config']['model_variant']}"))

    for data in best_result_values:
        print(f"{data['config']['model_name']}_{data['config']['model_variant']}".ljust(20),'fixes', len([x for x in list(data['results'].values()) if 'SUCCESS' in x[:n]]), data['config']['sampling_preferences'])

    print("Venn matrix:")
    venn_data = get_venn_matrix(best_result_values, n)
    plms = list(venn_data.keys())

    table_data = [["   "] + [PLMS_DISPLAY_NAME[plm] for plm in venn_data[plms[0]].keys()]]
    for plm1 in plms:
        assert plm1 in plms
        row = [PLMS_DISPLAY_NAME[plm1]]
        for plm2 in plms:
            if plms.index(plm2) < plms.index(plm1):
                row.append("  ")
                continue
            row.append(str(venn_data[plm1][plm2]))
        table_data.append(row)

    print(render_table(table_data))



if __name__ == "__main__":
    fire.Fire(main)

